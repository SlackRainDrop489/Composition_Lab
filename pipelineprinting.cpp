//
// Created by Quinn on 10/3/2025.
// AI WAS USED TO MAKE THE CODE IN THIS FILE
// The code in this file was generated by Gemini AI so that I could have a formatted account printer
// The reason for doing this was because I wanted to get all of the accounts printed out, and was not able to figure out how to get them properly spaced
//

#include "pipelineprinting.h"

#include <iostream>
#include <iomanip>

using FormattedTable = std::vector<std::vector<std::string>>;

void pipelineprinting::printTable(const FormattedTable& table) {
    if (table.empty()) return;

    // Get number of rows (fields) and columns (accounts)
    size_t num_columns = table.size();
    if (num_columns == 0) return;

    size_t num_rows = table[0].size();

    // --- 2. Calculate Maximum Widths for Automatic Sizing ---
    std::vector<int> max_widths(num_columns, 0);

    for (size_t j = 0; j < num_columns; ++j) {
        for (size_t i = 0; i < num_rows; ++i) {
            int current_width = table[j][i].length();
            max_widths[j] = std::max(max_widths[j], current_width);
        }
        // Add a buffer of 2 spaces for visual separation from the pipes
        max_widths[j] += 2;
    }

    // --- 3. Print the Table Row by Row ---
    for (size_t i = 0; i < num_rows; ++i) {
        std::cout << "|";
        for (size_t j = 0; j < num_columns; ++j) {
            const std::string& content = table[j][i];
            int width = max_widths[j];

            printCentered(content, width);
            std::cout << "|";
        }
        std::cout << std::endl;
    }
}

void pipelineprinting::printCentered(const std::string &text, int width) {
    int padding = width - text.length();

    if (padding <= 0) {
        std::cout << text;
        return;
    }

    int left_padding = padding / 2;
    int right_padding = padding - left_padding;

    std::cout << std::string(left_padding, ' ');
    std::cout << text;
    std::cout << std::string(right_padding, ' ');
}

FormattedTable pipelineprinting::formatCustomData(const std::vector<Account> &accounts) {
    FormattedTable table_data;

    for (const auto& account : accounts) {
        std::vector<std::string> column_data; // Holds all rows for this account

        column_data.push_back(std::to_string(account.option));

        column_data.push_back("ID: " + account.ID);

        column_data.push_back("Type: " + account.type);

        column_data.push_back("Holder: " + account.holder);

        std::stringstream ss;
        // Apply required formatting (fixed precision)
        ss << std::fixed << std::setprecision(2) << account.balance;
        column_data.push_back("Bal: " + ss.str());

        table_data.push_back(column_data);
    }

    return table_data;
}
